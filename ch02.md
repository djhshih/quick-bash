# Streaming Data through Pipes

Linux programs, irrespectively they are compiled, Bash scripts, or scripts written in another language, receive several inputs and sends several outputs. As shown in the previous chapter, programs receive **command-line arguments** and inherit **environment variables** from their parent processes. Aside from reading input files, they can also read from the **standard input**, or `stdin`. Additionally, they can also receive signals such as *terminate* (from `kill`) or *interrupt* (from `C-c`). For outputs, programs report their exit status (by updating `$?` upon exit), write to output files, and print to **standard output**, or `stdout`. Additionally, programs can also print to **standard error**, or `stderr`.

Standard input is what the user enters at the terminal when a program prompts
for user input. Standard output is what is output to and displayed on the terminal. Standard error is also displayed on the terminal by default, but this data stream is different from standard output.

We will use the following programs in this chapter:

Command       | Use
------------- | --------------------------------------------------------------
`head`        | Print the first part of files.
`tail`        | Print the last part of files.
`wc`          | Count lines, words, and bytes.
`tr`          | Translate characters.
`sort`        | Sort lines of text.
`shuffle`     | Shuffle lines of text.
`comm`        | Compare two sorted files line by line.
`uniq`        | Report unique lines in a file.
`cut`         | Cut out a column of a table.
`paste`       | Paste lines from files side by side.
`join`        | Joine two tables on a common field.

## Boilerplate

Let's start with a short template for writing your programs. Just a few lines of set up will make your life *so much* easier down the road.

```
#!/bin/bash
# Description of program

set -euo pipefail
IFS=$'\n\t'
```

The last two lines sets up the so-called **strict mode** for Bash. It will make your debugging much easier so that you are hunting for the
cause of some silent error. The `-e` flag ensures that the script stops on the first encountered error.
The `-u` flag disallows reading from undefined variables, which help prevent spelling mistakes in variable names.
For example, suppose you defined variable `language=Bash`, but when you later try to use it, you mispelled it as `langage`.
Under the `set -u` setting, `bash` will generate an error, because you are trying to read a variable whose value is
still undefined: `langage`. Under the default mode, your script will proceed until some non-silent error occurs.
Lastly, the `-o pipefail` flag prevents error in a series of pipes from being masked.
We will discuss `IFS` in a later [chapter](TODO).

So, we now segue into one of Bash's best features: pipes.

## Pipes

Pipe example

Allude to named Pipes


## Summary

Modularization

